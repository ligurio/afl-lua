--- Initialization.
--
-- This method is called when AFL++ starts up and is used to seed RNG and set
-- up buffers and state.
-- @function init
function init()
end

--- Mutate a data buffer (optional).
--
-- This method performs custom mutations on a given input. It also accepts an
-- additional test case. Note that this function is optional - but it makes
-- sense to use it. You would only skip this if `post_process` is used to fix
-- checksums etc. so if you are using it, e.g., as a post processing library.
-- Note that a length > 0 must be returned!
--
-- @string buf
-- @number max_size
-- @string add_buf
-- @return mutated_out, a modified version of buffer.
--
-- @function fuzz
function fuzz(buf, max_size, add_buf)
    print(buf, max_size, add_buf)
end

--- Fuzz count (optional).
--
-- When a queue entry is selected to be fuzzed, afl-fuzz selects the number of
-- fuzzing attempts with this input based on a few factors. If, however, the
-- custom mutator wants to set this number instead on how often it is called
-- for a specific queue entry, use this function. This function is most useful
-- if AFL_CUSTOM_MUTATOR_ONLY is not used.
--
-- @string buf
-- @string add_buf
-- @number max_size
-- @return cnt
--
-- @function fuzz_count
function fuzz_count(buf, max_size, add_buf)
    print(buf, max_size, add_buf)
end

--- Describe (optional).
--
-- When this function is called, it shall describe the current test case,
-- generated by the last mutation. This will be called, for example, to name
-- the written test case file after a crash occurred. Using it can help to
-- reproduce crashing mutations.
--
-- @number max_description_length
-- @return desc, a string with description.
--
-- @function fuzz_count
function describe(max_description_length)
    print(max_description_length)
end

--- Post-processing (optional).
--
-- For some cases, the format of the mutated data returned from the custom
-- mutator is not suitable to directly execute the target with this input. For
-- example, when using libprotobuf-mutator, the data returned is in a protobuf
-- format which corresponds to a given grammar. In order to execute the target,
-- the protobuf data must be converted to the plain-text format expected by the
-- target. In such scenarios, the user can define the post_process function.
-- This function is then transforming the data into the format expected by the
-- API before executing the target.
--
-- @string buf
-- @return out_buf, a modified version of buffer.
--
-- @function post_process
function post_process(buf)
     print(buf)
end

--- Havoc mutation (optional).
--
-- havoc_mutation performs a single custom mutation on a given input. This
-- mutation is stacked with other mutations in havoc. The other method,
-- havoc_mutation_probability, returns the probability that havoc_mutation is
-- called in havoc. By default, it is 6%.
--
-- @string buf
-- @number max_size
-- @return mutated_out, a modified version of buf.
--
-- @function havoc_mutation
function havoc_mutation(buf, max_size)
     print(buf, max_size)
end

--- Havoc mutation probability.
--
-- havoc_mutation performs a single custom mutation on a given input. This
-- mutation is stacked with other mutations in havoc. The other method,
-- havoc_mutation_probability, returns the probability that havoc_mutation is
-- called in havoc. By default, it is 6%.
--
-- @return num, integer in the range [0, 100].
--
-- @function havoc_mutation_probability
function havoc_mutation_probability()
end

--- Queue get (optional).
--
-- This method determines whether the custom fuzzer should fuzz the current
-- queue entry or not.
--
-- @string filename
-- @return rc, returns true if "filename" should be used.
--
-- @function queue_get
function queue_get(filename)
    print(filename)
end

--- Queue new entry (optional).
--
-- This method is called after adding a new test case to the queue. If the
-- contents of the file was changed, return True, False otherwise.
--
-- @string filename_new_queue
-- @string filename_orig_queue
--
-- @function queue_new_entry
function queue_new_entry(filename_new_queue, filename_orig_queue)
    print(filename_new_queue, filename_orig_queue)
end

--- Introspection (optional).
--
-- This method is called after a new queue entry, crash or timeout is
-- discovered if compiled with INTROSPECTION. The custom mutator can then
-- return a string (const char *) that reports the exact mutations used.
--
-- @return string
--
-- @function introspection
function introspection()
end

--- Deinit.
--
-- The last method to be called, deinitializing the state.
--
-- @function deinit
function deinit()
end

--- Initialization of trim (optional).
--
-- This method is called at the start of each trimming operation and receives
-- the initial buffer. It should return the amount of iteration steps possible
-- on this input (e.g., if your input has n elements and you want to remove
-- them one by one, return n, if you do a binary search, return log(n), and so
-- on).
--
-- If your trimming algorithm doesn’t allow to determine the amount of
-- (remaining) steps easily (esp. while running), then you can alternatively
-- return 1 here and always return 0 in post_trim until you are finished and no
-- steps remain. In that case, returning 1 in post_trim will end the trimming
-- routine. The whole current index/max iterations stuff is only used to show
-- progress.
--
-- @string buf
-- @return cnt, a number of steps needed for trimming process.
--
-- @function init_trim
function init_trim(buf)
    print(buf)
end

--- Trim (optional).
--
-- This method is called for each trimming operation. It doesn’t have any
-- arguments because there is already the initial buffer from init_trim and we
-- can memorize the current state in the data variables. This can also save
-- reparsing steps for each iteration. It should return the trimmed input
-- buffer.
--
-- @return out_buf, a trimmed buffer.
--
-- @function trim
function trim()
end

--- Post trim (optional).
--
-- This method is called after each trim operation to inform you if your
-- trimming step was successful or not (in terms of coverage). If you receive a
-- failure here, you should reset your input to the last known good state. In
-- any case, this method must return the next trim iteration index (from 0 to
-- the maximum amount of steps you returned in init_trim).
--
-- @param success
-- @return idx, next trim index.
--
-- @function post_trim
function post_trim(success)
     print(success)
end
